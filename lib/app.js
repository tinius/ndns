// Generated by CoffeeScript 1.10.0
var bubble_promises, d, d3Blue, e, g, getJSON, height, margins, ractive, scale, w, width;

w = window;

d = document;

e = d.documentElement;

g = d.getElementsByTagName('body')[0];

width = w.innerWidth || e.clientWidth || g.clientWidth;

if (width > 800) {
  width = 800;
}

width *= 0.96;

margins = 10;

height = 350;

scale = null;

d3Blue = '#1f77b4';

getJSON = function(url) {
  var promise;
  return promise = new RSVP.Promise(function(resolve, reject) {
    var client, handler;
    handler = function() {
      if (this.readyState === this.DONE) {
        if (this.status === 200) {
          return resolve(this.response);
        } else {
          return reject(this);
        }
      }
    };
    client = new XMLHttpRequest();
    client.open('GET', url);
    client.onreadystatechange = handler;
    client.responseType = 'json';
    client.setRequestHeader('Accept', 'application/json');
    return client.send();
  });
};

ractive = new Ractive({
  el: '#container',
  template: '#template',
  data: {
    margins: margins,
    height: height,
    width: width,
    diameter: 200,
    d3Blue: d3Blue,
    pack: d3_hierarchy.pack().size([width, height]),
    barScale: function(arr, value) {
      var max;
      max = Math.max.apply(Math, arr);
      return width * value / max;
    },
    barColours: function(i) {
      var col, j, ref, x;
      scale = d3.scale.category20().domain(d3.range(20));
      col = chroma(scale(0));
      for (x = j = 0, ref = i; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        col = col.darken(0.5);
      }
      return col;
    },
    cscale: function(i) {
      scale = d3.scale.category20().domain(d3.range(20));
      return scale(i);
    },
    quintileLabels: ['Quintile 5 (highest income)', 'Quintile 4', 'Quintile 3', 'Quintile 2', 'Quintile 1'],
    transformString: function(x, y) {
      return "translate(" + x + "," + y + ")";
    },
    sortBubbles: function(a, b) {
      if (a.name > b.name) {
        return -1;
      } else {
        return 1;
      }
    },
    xScale: d3.scale.linear().domain([0, 58]).range([margins, width - margins]),
    yScale: function(l) {
      var max;
      max = Math.max.apply(Math, l);
      return d3.scale.linear().domain([0, max]).range([margins + 24, height - margins]);
    },
    getX: function(value) {
      return this.get('xScale')(value);
    },
    getY: function(value, arr) {
      return (this.get('yScale')(arr))(value);
    },
    maxLabel: function(obj) {
      var max;
      max = Math.max.apply(Math, obj.vals).toFixed(2);
      return max + ' ' + obj.unit;
    },
    halfLabel: function(obj) {
      var half;
      half = (Math.max.apply(Math, obj.vals) / 2).toFixed(2);
      return half + ' ' + obj.unit;
    },
    highlight: function(node) {
      if (this.get('detailFood') !== void 0 && node.name === ractive.get('detailFood').name) {
        return chroma(this.get('bubbleColours')(node)).darken().hex();
      } else {
        return 'transparent';
      }
    },
    simplify: function(nodes) {
      return nodes.map(function(node) {
        return {
          r: node.r,
          x: node.x,
          y: node.y,
          value: node.value,
          name: node.data.name,
          category: node.children === void 0 ? node.parent.data.name : node.parent !== null ? node.data.name : void 0,
          children: node.children ? true : false
        };
      }).sort(ractive.get('sortBubbles'));
    }
  }
});

ractive.on({
  'details': function(event) {
    if (ractive.get('detailFood') && event.context.name === ractive.get('detailFood').name) {
      return ractive.set('detailFood', void 0);
    } else {
      return ractive.set('detailFood', event.context);
    }
  }
});

getJSON('data/quintiles.json').then(function(json) {
  ractive.set('foods', json['total']);
  ractive.observe('selectedFoodKey', function(key) {
    var x;
    x = json['male'][key]['Mean'].slice(0).reverse();
    return this.animate('selectedFood', x, {
      easing: 'easeInOut',
      duration: 800
    });
  });
  return null;
});

bubble_promises = {
  energy: getJSON('data/energy.json'),
  protein: getJSON('data/protein.json'),
  carbohydrate: getJSON('data/carbohydrates.json'),
  fat: getJSON('data/fat.json')
};

RSVP.hash(bubble_promises).then(function(datasets) {
  var categories;
  ractive.set('macros', datasets);
  categories = datasets['energy']['total']['children'].map(function(entry) {
    return entry.name;
  });
  ractive.set('categories', categories);
  scale = d3.scale.category20().domain(categories);
  ractive.set('bubbleColours', function(node) {
    if (node.children === true) {
      return 'transparent';
    } else {
      return scale(node.category);
    }
  });
  ractive.set('legendColours', function(str) {
    return scale(str);
  });
  ractive.observe('selectedMacroKey', function(key) {
    var f, j, len, macro, packed, root, x;
    root = d3_hierarchy.hierarchy(datasets[key]['total']);
    packed = (this.get('pack')(root.sum(function(d) {
      if (parseFloat(d.value) > 0) {
        return d.value;
      } else {
        return 0.01;
      }
    })).sort(this.get('sortBubbles'))).descendants();
    macro = this.get('simplify')(packed);
    this.animate('selectedMacro', macro, {
      easing: 'easeInOut',
      duration: 800
    });
    if (this.get('detailFood') !== void 0) {
      f = JSON.parse(JSON.stringify(this.get('detailFood')));
      for (j = 0, len = macro.length; j < len; j++) {
        x = macro[j];
        if (x.name === f.name) {
          f.value = x.value;
        }
      }
      return this.animate('detailFood', f, {
        easing: 'easeInOut',
        duration: 800
      });
    }
  });
  return null;
}, function(error) {
  return console.log(error);
});

getJSON('data/food_history.json').then(function(datasets) {
  ractive.set('histories', datasets.history.slice(0));
  return ractive.observe('selectedTimelineIndex', function(i) {
    return ractive.set('selectedTimeline', this.get('histories')[i]);
  });
});
